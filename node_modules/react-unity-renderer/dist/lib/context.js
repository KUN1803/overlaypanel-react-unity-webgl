"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnityContext = void 0;
/**
 * Defines a Unity WebGL context.
 *
 * The context is responsible for the initial startup parameters of the
 * `UnityRenderer`, as well as receiving events and emitting RPCs to Unity.
 *
 */
var UnityContext = /** @class */ (function () {
    /**
     * Creates a new `UnityContext` and registers the global event callback.
     *
     * @param {UnityLoaderConfig} config A loader configuration object.
     */
    function UnityContext(config) {
        this.handlers = {};
        this.config = config;
        this.mountGlobalEventRegistry();
        this.mountGlobalLookupHandler();
    }
    /**
     * Retrieves the currently activte loader configuration.
     *
     * @returns {UnityLoaderConfig} The current loader configuration object.
     */
    UnityContext.prototype.getConfig = function () {
        return this.config;
    };
    /**
     * Sets the Unity instance this `UnityContext` is responsible for.
     *
     * @param {UnityInstance} instance The running Unity instance
     */
    UnityContext.prototype.setInstance = function (instance) {
        this.instance = instance;
    };
    /**
     * Shuts down the running Unity instance, then unregisters the existing
     * event handlers.
     *
     * @param {() => void} onShutdownFinished Callback to execute when the
     * shutdown has been completed.
     *
     * @returns {void} void
     */
    UnityContext.prototype.shutdown = function (onShutdownFinished) {
        var _this = this;
        if (!this.instance) {
            if (onShutdownFinished)
                onShutdownFinished();
            return;
        }
        this.instance
            .Quit()
            .then(function () {
            _this.instance = undefined;
            // remove all instance event handlers
            Object.keys(_this.handlers).forEach(function (name) { return _this.off(name); });
            if (onShutdownFinished)
                onShutdownFinished();
        })
            .catch(function (e) {
            // eslint-disable-next-line no-console
            return console.error('error while shutting down webgl instance', e);
        });
    };
    /**
     * Sends a message to the running Unity instance.
     *
     * @param {string} objectName The `GameObject` on which to call the method.
     * @param {string} methodName The name of the method which should be invoked.
     * @param {(string | number)} value The value to pass to the method
     * as the first parameter.
     * @returns {void} void
     */
    UnityContext.prototype.emit = function (objectName, methodName, value) {
        if (!this.instance) {
            // eslint-disable-next-line no-console
            console.error('cannot send unity message: missing instance');
            return;
        }
        try {
            this.instance.SendMessage(objectName, methodName, value);
        }
        catch (e) {
            // eslint-disable-next-line no-console
            console.error('failed to send message to unity instance:', e);
        }
    };
    /**
     * Delegates an event handler to handle an event (from Unity) by using a
     * callback function.
     *
     * @param {string} name The (unique) name of the event.
     * @param {UnityEventCallback} callback The callback which should be invoked
     * upon the occurence of this event.
     */
    UnityContext.prototype.on = function (name, callback) {
        // unregister any old event handler
        if (this.handlers[name])
            this.off(name);
        // set new event handler
        this.handlers[name] = callback;
        // create global registry key if needed
        if (window.__UnityBridgeRegistry__ &&
            (!window.__UnityBridgeRegistry__[name] || // key does not exist
                (window.__UnityBridgeRegistry__[name] && // key is not an array
                    !Array.isArray(window.__UnityBridgeRegistry__[name]))))
            window.__UnityBridgeRegistry__[name] = [];
        // add callback to event registry
        window.__UnityBridgeRegistry__[name].push(callback);
    };
    /**
     * Removes a instance-local event handler from the global event registry.
     *
     * @param {string} name Name of the local event handler.
     */
    UnityContext.prototype.off = function (name) {
        var _this = this;
        if (window.__UnityBridgeRegistry__ &&
            window.__UnityBridgeRegistry__[name] &&
            Array.isArray(window.__UnityBridgeRegistry__[name]))
            window.__UnityBridgeRegistry__[name] = window.__UnityBridgeRegistry__[name].filter(function (cb) { return cb !== _this.handlers[name]; });
    };
    /**
     * Enables or disables fullscreen mode.
     *
     * @param {booolean} enabled Whether to enable or disable fullscreen.
     * @returns {void} void
     */
    UnityContext.prototype.setFullscreen = function (enabled) {
        if (!this.instance)
            return;
        this.instance.SetFullscreen(enabled ? 1 : 0);
    };
    /**
     * Creates a global event registry which holds a list of callbacks for
     * each registered event name.
     * This enables fairly fail-safe multi-tenancy event handling.
     *
     * @returns {void} void
     */
    UnityContext.prototype.mountGlobalEventRegistry = function () {
        // create global handler registry if there is none
        if (!window.__UnityBridgeRegistry__ ||
            typeof window.__UnityBridgeRegistry__ !== 'object')
            window.__UnityBridgeRegistry__ = {};
    };
    /**
     * Creates the global lookup handler which looks up the list of event
     * handlers for a given event name and executes them with the arguments
     * of the callback.
     *
     * If no event handler is registered for an event that is received, a
     * warning will be logged to the console.
     *
     * @returns {void} void
     */
    UnityContext.prototype.mountGlobalLookupHandler = function () {
        // either returns a callback which executes any registered event handler
        // or a fallback handler
        var lookupHandler = function (name) {
            if (window.__UnityBridgeRegistry__ &&
                window.__UnityBridgeRegistry__[name] &&
                Array.isArray(window.__UnityBridgeRegistry__[name]) &&
                window.__UnityBridgeRegistry__[name].length > 0)
                // return a function taking any params and executing them on all
                // registred event handlers
                return function () {
                    var params = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        params[_i] = arguments[_i];
                    }
                    window.__UnityBridgeRegistry__[name].forEach(function (handler) {
                        try {
                            handler.apply(void 0, params);
                        }
                        catch (e) {
                            // eslint-disable-next-line no-console
                            console.warn("failed to execute event handler for event \"" + name + "\":", e);
                        }
                    });
                };
            return function () {
                // eslint-disable-next-line no-console
                return console.warn("received event \"" + name + "\": no handlers registered");
            };
        };
        // create global lookup handler which uses the registry, but only
        // if it is not registered yet
        if (!window.UnityBridge || typeof window.UnityBridge !== 'function')
            window.UnityBridge = lookupHandler;
    };
    return UnityContext;
}());
exports.UnityContext = UnityContext;
//# sourceMappingURL=context.js.map